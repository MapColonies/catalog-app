import React, { useEffect, useCallback, useState } from 'react';
import { FormattedMessage, useIntl } from 'react-intl';
import { observer } from 'mobx-react';
import { FormikErrors, FormikValues, useFormik } from 'formik';
import { cloneDeep } from 'lodash';
import * as Yup from 'yup';
import { DraftResult } from 'vest/vestResult';
import { DialogContent } from '@material-ui/core';
import { Button, Dialog, DialogTitle, IconButton } from '@map-colonies/react-core';
import { Box } from '@map-colonies/react-components';
import { GraphQLError } from '../../../common/components/error/graphql.error-presentor';
import { ValidationsError } from '../../../common/components/error/validations.error-presentor';
import { Mode } from '../../../common/models/mode.enum';
import {
  BestRecordModelType,
  EntityDescriptorModelType,
  Layer3DRecordModel,
  LayerMetadataMixedUnion,
  LayerRasterRecordModel,
  RecordType,
  useQuery,
  useStore,
  ValidationConfigModelType,
  FieldConfigModelType
} from '../../models';
import { ILayerImage } from '../../models/layerImage';
import { Layer3DRecordInput, LayerRasterRecordInput } from '../../models/RootStore.base';
import { LayersDetailsComponent } from './layer-details';
import { FieldConfigModelKeys, IRecordFieldInfo, Layer3DRecordModelKeys, LayerRasterRecordModelKeys } from './layer-details.field-info';
import { IngestionFields } from './ingestion-fields';
import { getFlatEntityDescriptors } from './descriptors';
import suite from './validate';

import './entity-dialog.css';

const DEFAULT_ID = 'DEFAULT_ID';
const IMMEDIATE_EXECUTION = 0;
const NONE = 0;

interface EntityDialogComponentProps {
  isOpen: boolean;
  onSetOpen: (open: boolean) => void;
  recordType?: RecordType;
  layerRecord?: ILayerImage | null;
}

const buildRecord = (recordType: RecordType): ILayerImage => {
  const record = {} as Record<string, any>;
  switch(recordType) {
    case RecordType.RECORD_3D:
      Layer3DRecordModelKeys.forEach(key => {
        record[key as string] = undefined;
      });
      record.id = DEFAULT_ID;
      record['__typename'] = Layer3DRecordModel.properties['__typename'].name.replaceAll('"','');
      break;
    case RecordType.RECORD_RASTER:
      LayerRasterRecordModelKeys.forEach(key => {
        record[key as string] = undefined;
      });
      record['__typename'] = LayerRasterRecordModel.properties['__typename'].name.replaceAll('"','');
      break;
    default:
      break;
  }
  record.type = recordType;
  return record as ILayerImage;
};

const buildFieldInfo = (): IRecordFieldInfo => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const recordFieldInfo = {} as Record<string, any>;
  FieldConfigModelKeys.forEach(key => {
    recordFieldInfo[key as string] = undefined;
  });
  return recordFieldInfo as IRecordFieldInfo;
};

const getLabel = (recordType: RecordType): string => {
  return recordType === RecordType.RECORD_3D ? 'field-names.3d.fileNames' : 'field-names.raster.fileNames';
};

const getTooltip = (recordType: RecordType): string => {
  return recordType === RecordType.RECORD_3D ? 'field-names.3d.fileNames.tooltip' : 'field-names.raster.fileNames.tooltip';
};
  
export const EntityDialogComponent: React.FC<EntityDialogComponentProps> = observer((props: EntityDialogComponentProps) => {
  const { isOpen, onSetOpen, recordType } = props;
  let layerRecord = cloneDeep(props.layerRecord);
  const directory = '';
  let fileNames = '';
  const mutationQuery = useQuery();
  const store = useStore();
  const intl = useIntl();
  const [validationResults, setValidationResults] = useState<DraftResult>({} as DraftResult);
  const [descriptors, setDescriptors] = useState<any[]>([]);
  const [schema, setSchema] = useState<Record<string, Yup.AnySchema>>({});
  const [inputValues, setInputValues] = useState<FormikValues>({});
  
  let mode = Mode.EDIT;
  if (layerRecord === undefined && recordType !== undefined) {
    mode = Mode.NEW;
    if (recordType === RecordType.RECORD_3D) {
      fileNames = 'tileset.json';
    }
    layerRecord = buildRecord(recordType);
  }

  const ingestionFields = [
    {
      ...buildFieldInfo(),
      fieldName: 'directory',
      label: 'field-names.ingestion.directory',
      isRequired: true,
      isAutoGenerated: false,
      infoMsgCode: [
        'info-general-tooltip.required'
      ]
    },
    {
      ...buildFieldInfo(),
      fieldName: 'fileNames',
      label: getLabel(recordType as RecordType),
      isRequired: true,
      isAutoGenerated: false,
      infoMsgCode: [
        'info-general-tooltip.required',
        getTooltip(recordType as RecordType)
      ]
    }
  ];

  useEffect(() => {
    const descriptors = getFlatEntityDescriptors(
      layerRecord as LayerMetadataMixedUnion,
      store.discreteLayersStore.entityDescriptors as EntityDescriptorModelType[]
    );
  
    const yupSchema: Record<string, any> = {};
    [
      ...ingestionFields,
      ...descriptors
    ].forEach(field => {
      if (field.isRequired as boolean && field.isAutoGenerated !== true) {
        const fieldName: string = field.fieldName as string;
        yupSchema[fieldName] = Yup.string().required(
          intl.formatMessage(
            { id: 'validation-general.required' },
            { fieldName: intl.formatMessage({ id: field.label }) }
          )
        );
      }
    })
    setSchema(yupSchema);
  
    const desc =  [
      ...ingestionFields,
      ...descriptors
    ].map((field: FieldConfigModelType) => {
      return {
        ...field,
        validation: field.validation?.map((val: ValidationConfigModelType) => {
          const firstParam = intl.formatMessage({ id: field.label });
          const secondParamType = val.type === 'FIELD' ? val.errorMsgCode?.substring(val.errorMsgCode.lastIndexOf('.') + 1) : '';
          // @ts-ignore
          const secondParam = (val.type === 'FIELD' && secondParamType !== '' && val[secondParamType] !== undefined) ?
            // @ts-ignore
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            intl.formatMessage({ id: `field-names.raster.${val[secondParamType]}` }) :
            '';
          return {
            ...val,
            errorMsgTranslation: intl.formatMessage(
              { id: val.errorMsgCode },
              { fieldName: firstParam, fieldToCompare: secondParam }
            )
          };
        })
      };
    });
    setDescriptors(desc as any[]);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (validationResults.errorCount === NONE) {
      if (mode === Mode.EDIT) {
        if (inputValues.__typename !== 'BestRecord') {
          mutationQuery.setQuery(store.mutateUpdateMetadata({
            data: {
              id: inputValues.id as string,
              type: inputValues.type as RecordType,
              productName: inputValues.productName as string,
              description: inputValues.description as string,
              // sensorType: inputValues.sensorType as SensorType[],
              productSubType: inputValues.productSubType as string,
              producerName: inputValues.producerName as string,
              classification: inputValues.classification as string ,
              keywords: inputValues.keywords as string,
            }
          }));
        } else {
          setTimeout(() => {
            store.bestStore.editBest({
              ...(inputValues as BestRecordModelType),
              // @ts-ignore
              sensorType: (inputValues.sensorType !== undefined) ? JSON.parse('[' + (inputValues.sensorType as string) + ']') as string[] : []
            });
          }, IMMEDIATE_EXECUTION);
          closeDialog();
        }
      } else {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const { directory, fileNames, __typename, ...metadata } = inputValues;
        switch(recordType){
          case RecordType.RECORD_3D:
            mutationQuery.setQuery(store.mutateStart3DIngestion({
              data: {
                directory: directory as string,
                fileNames: [ fileNames as string ],
                metadata: metadata as Layer3DRecordInput,
                type: RecordType.RECORD_3D
              }
            }));
            break;
          case RecordType.RECORD_RASTER:
            mutationQuery.setQuery(store.mutateStartRasterIngestion({
              data: {
                directory: directory as string,
                fileNames: (fileNames as string).split(","),
                metadata: metadata as LayerRasterRecordInput,
                type: RecordType.RECORD_RASTER
              }
            }));
            break;
          default:
            break;
        }
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [validationResults]);

  
  const formik = useFormik({
    initialValues: layerRecord as FormikValues,
    validationSchema: Yup.object({
      ...schema
    }),
    onSubmit: values => {
      console.log(values);
      
      setInputValues(values);
      // eslint-disable-next-line
      const vestSuite = suite(descriptors as FieldConfigModelType[], values);
      // eslint-disable-next-line
      setValidationResults(vestSuite.get());
    }
  });
 
  const closeDialog = useCallback(() => {
    onSetOpen(false);
  }, [onSetOpen]);
  
  useEffect(() => {
    // @ts-ignore
    if (!mutationQuery.loading && (mutationQuery.data?.updateMetadata === 'ok' || mutationQuery.data?.start3DIngestion === 'ok' || mutationQuery.data?.startRasterIngestion === 'ok')) {
      closeDialog();
      store.discreteLayersStore.updateLayer(formik.values as ILayerImage);
      store.discreteLayersStore.selectLayerByID((formik.values as ILayerImage).id);
    }
  }, [mutationQuery.data, mutationQuery.loading, closeDialog, store.discreteLayersStore, formik.values]);

  const isInvalidForm = (): boolean => {
    return Object.keys(formik.errors).length > NONE;
  };

  const getErrors = (formikObject: FormikErrors<FormikValues>): Record<string, string[]> => {
    const validationsObject: Record<string, string[]> = {};
    Object.entries(formikObject).forEach(([key, value]) => {
      if (formik.getFieldMeta(key).touched) {
        validationsObject[key] = [ value as string ];
      }
    });
    return validationsObject;
  };

  return (
    <Box id="entityDialog">
      <Dialog open={isOpen} preventOutsideDismiss={true}>
        <DialogTitle>
          <FormattedMessage id={ mode === Mode.NEW ? (recordType === RecordType.RECORD_3D ? 'general.title.new.3d' : 'general.title.new.raster') : 'general.title.edit' }/>
          <IconButton
            className="closeIcon mc-icon-Close"
            label="CLOSE"
            onClick={ (): void => { closeDialog(); } }
          />
        </DialogTitle>
        <DialogContent className="dialogBody">
          <form onSubmit={formik.handleSubmit} className="form">
            {
              mode === Mode.NEW && <IngestionFields fields={ingestionFields} values={[ directory, fileNames ]} formik={formik}/>
            }
            <Box className={(mode === Mode.NEW) ? 'section' : ''}>
              <LayersDetailsComponent layerRecord={layerRecord} mode={mode} formik={formik} /*errors={validationResults.getErrors()}*//>
            </Box>
            <Box className="buttons">
              {
                Object.keys(formik.errors).length > NONE && <ValidationsError errors={getErrors(formik.errors)}/>
              }
              {
                validationResults.errorCount > NONE && <ValidationsError errors={validationResults.getErrors()}/>
              }
              {
                // eslint-disable-next-line
                mutationQuery.error !== undefined && <GraphQLError error={mutationQuery.error}/>
              }
              <Button
                type="button"
                onClick={(): void => { closeDialog(); }}
              >
                <FormattedMessage id="general.cancel-btn.text"/>
              </Button>
              <Button
                raised 
                type="submit" 
                disabled={mutationQuery.loading || !formik.dirty || isInvalidForm()}
              >
                <FormattedMessage id="general.ok-btn.text"/>
              </Button>
            </Box>
          </form>
        </DialogContent>
      </Dialog>
    </Box>
  );
});

import React, { useEffect, useMemo, useState } from 'react';
import { useIntl } from 'react-intl';
import { Feature, Polygon, BBox, Point } from 'geojson';
import { isEmpty } from 'lodash';
import { observer } from 'mobx-react-lite';
import { Properties, Geometry } from '@turf/helpers';
import area from '@turf/area';
import intersect from '@turf/intersect';
import centroid from '@turf/centroid';
import bboxPolygon from '@turf/bbox-polygon';
import { 
  CesiumWFSLayer,
  CesiumMath,
  CesiumSceneMode,
  CesiumGeoJsonDataSource,
  CesiumCesiumPolygonGraphics,
  CesiumCesiumEntity,
  CesiumColor,
  CesiumCesiumPolylineGraphics,
  CesiumCartesian3,
  CesiumJulianDate,
  CesiumCartographic,
  CesiumPositionProperty,
  CesiumCesiumBillboardGraphics,
  CesiumVerticalOrigin,
  CesiumHeightReference,
  CesiumPolygonHierarchy,
  CesiumCartesian2,
  CesiumScene,
  CesiumSceneTransforms,
  CesiumEllipsoid,
  ICesiumWFSLayerLabelTextField,
  CesiumViewer,
  useCesiumMapViewstate,
  CesiumGeojsonLayer,
 } from '@map-colonies/react-components';
import CONFIG from '../../../../common/config';
import { useEnums } from '../../../../common/hooks/useEnum.hook';
import { EntityDescriptorModelType, LayerRasterRecordModelType, useStore } from '../../../models';
import useZoomLevelsTable from '../../export-layer/hooks/useZoomLevelsTable';
import { getFlatEntityDescriptors } from '../../layer-details/utils';
import { ILayerImage } from '../../../models/layerImage';


export const PolygonParts: React.FC = observer(() => {
  const store = useStore();
  const intl = useIntl();
  const ENUMS = useEnums();
  // const cesiumViewer = useCesiumMap();
  const { viewState: mapViewState } = useCesiumMapViewstate();
  const ZOOM_LEVELS_TABLE = useZoomLevelsTable();
  const [zoomLevel, setZoomLevel] = useState(mapViewState.currentZoomLevel);
  const [activeLayer, setActiveLayer] = useState(store.discreteLayersStore.polygonPartsLayer);
  const [showFootprint, setShowFootprint] = useState(false);

  useEffect(() => {
    if (JSON.stringify(activeLayer) !== JSON.stringify(store.discreteLayersStore.polygonPartsLayer)) {
      setActiveLayer(store.discreteLayersStore.polygonPartsLayer);
      if (store.discreteLayersStore.polygonPartsLayer === undefined) {
        setShowFootprint(false);
      }
    }
    if (store.discreteLayersStore.polygonPartsLayer) {
      if (zoomLevel !== mapViewState.currentZoomLevel) {
        setZoomLevel(mapViewState.currentZoomLevel);
      }
    }
  }, [store.discreteLayersStore.polygonPartsLayer, mapViewState.currentZoomLevel]);

  useEffect(() => {
    if (activeLayer) {
      if (zoomLevel && zoomLevel < optionsPolygonParts.zoomLevel) {
        setShowFootprint(false);
      } else {
        setShowFootprint(true);
      }
    }
  }, [zoomLevel, activeLayer]);

  const polygonPartsFieldLabels = useMemo(
    () => {
      const partialLabels = getFlatEntityDescriptors(
        'PolygonPartRecord',
        store.discreteLayersStore.entityDescriptors as EntityDescriptorModelType[]
      )
      .filter(descriptor => !descriptor.isAutoGenerated)
      .map(descriptor => [descriptor.fieldName, descriptor.label]);

      return [
        ...partialLabels,
        ['productVersion','field-names.raster.productVersion'],
        ['ingestionDateUTC', 'field-names.raster.ingestion-date']
      ];
    },
    [store.discreteLayersStore.entityDescriptors]
  );

  const getFieldLabelTranslation = (fieldName: string): string => {
    let res = 'N/A';
    const fieldTuple = polygonPartsFieldLabels.find((fieldTuple)=> fieldName.toLocaleLowerCase() === fieldTuple[0]?.toLocaleLowerCase());
    if(fieldTuple){
      res = intl.formatMessage({ id: fieldTuple[1] as string })
    }
    return res;
  };

  const POINT_STROKE = CONFIG.POLYGON_PARTS.STYLE.billBoardStrokeColor;//'#FFFF00';
  const BRIGHT_GREEN = CONFIG.POLYGON_PARTS.STYLE.highResolutionColor;//'#01FF1F';
  const LIGHT_BLUE = CONFIG.POLYGON_PARTS.STYLE.hoverColor;//'#24AEE9';
  const LABEL_INTERSECTION_RATIO = 0.7;
  const SHOW_PP_ZOOM_LEVEL = 7;

  const metaPolygonParts = {
    ...activeLayer,
    id: `virt-PP_${activeLayer?.id}`,
    featureStructure: {
      layerName: 'polygonParts:layer',
      aliasLayerName: `${activeLayer?.productName} (${intl.formatMessage({ id: 'field-names.dem.layerPolygonParts' })})`,
      fields: [
        // {
        //   fieldName: 'id',
        //   aliasFieldName: 'id',
        //   type: 'String',
        // },
        // {
        //   fieldName: 'catalogId',
        //   aliasFieldName: 'catalogId',
        //   type: 'String',
        // },
        // {
        //   fieldName: 'productId',
        //   aliasFieldName: 'productId',
        //   type: 'String',
        // },
        // {
        //   fieldName: 'productType',
        //   aliasFieldName: 'productType',
        //   type: 'String',
        // },
        {
          fieldName: 'sourceId',
          aliasFieldName: getFieldLabelTranslation('sourceId'),
          type: 'String',
        },
        {
          fieldName: 'sourceName',
          aliasFieldName: getFieldLabelTranslation('sourceName'),
          type: 'String',
        },
        {
          fieldName: 'productVersion',
          aliasFieldName: getFieldLabelTranslation('productVersion'),
          type: 'String',
        },
        {
          fieldName: 'ingestionDateUTC',
          aliasFieldName: getFieldLabelTranslation('ingestionDateUTC'),
          type: 'Date',
        },
        {
          fieldName: 'imagingTimeBeginUTC',
          aliasFieldName: getFieldLabelTranslation('imagingTimeBeginUTC'),
          type: 'Date',
        },
        {
          fieldName: 'imagingTimeEndUTC',
          aliasFieldName: getFieldLabelTranslation('imagingTimeEndUTC'),
          type: 'Date',
        },
        {
          fieldName: 'resolutionDegree',
          aliasFieldName: getFieldLabelTranslation('resolutionDegree'),
          type: 'Number',
        },
        {
          fieldName: 'resolutionMeter',
          aliasFieldName: getFieldLabelTranslation('resolutionMeter'),
          type: 'Number',
        },
        {
          fieldName: 'sourceResolutionMeter',
          aliasFieldName: getFieldLabelTranslation('sourceResolutionMeter'),
          type: 'Number',
        },
        {
          fieldName: 'horizontalAccuracyCe90',
          aliasFieldName: getFieldLabelTranslation('horizontalAccuracyCe90'),
          type: 'Number',
        },
        {
          fieldName: 'sensors',
          aliasFieldName: getFieldLabelTranslation('sensors'),
          type: 'String',
        },
        {
          fieldName: 'countries',
          aliasFieldName: getFieldLabelTranslation('countries'),
          type: 'String',
        },
        {
          fieldName: 'cities',
          aliasFieldName: getFieldLabelTranslation('cities'),
          type: 'String',
        },
        {
          fieldName: '_description',
          aliasFieldName: getFieldLabelTranslation('description'),
          type: 'String',
        },
      ],
    }
  };

  const buildWFSUrl = (layer: ILayerImage) => {
    const token = CONFIG.ACCESS_TOKEN.TOKEN_VALUE;
    if(layer){
      const url = layer.links?.find(link => link.protocol === 'WFS').url.split(/[?#]/)[0];
      return `${url}?token=${token}`
    } else {
      return 'NO_CURRENT_LAYER';
    }
  };

  const buildFeatureType = (layer: ILayerImage) => {
    if(layer){
      // `${CONFIG.POLYGON_PARTS.FEATURE_TYPE_PREFIX}${(layer as LayerRasterRecordModelType).productId}-${ENUMS[(layer as LayerRasterRecordModelType).productType as string].realValue}`
      let featureType = '';
      featureType += CONFIG.POLYGON_PARTS.FEATURE_TYPE_PREFIX;
      featureType += (layer as LayerRasterRecordModelType).productId;
      featureType += '-';
      featureType += ENUMS[(layer as LayerRasterRecordModelType).productType as string].realValue;
      return featureType;
    } else {
      return 'NO_CURRENT_LAYER';
    }
  };

  const optionsPolygonParts = {
    url: buildWFSUrl(activeLayer as ILayerImage),
    featureType: buildFeatureType(activeLayer as ILayerImage),
    style: {
      color: BRIGHT_GREEN,
      hover: LIGHT_BLUE,
    },
    pageSize: CONFIG.WFS.MAX.PAGE_SIZE,//300,
    zoomLevel: SHOW_PP_ZOOM_LEVEL,//7
    maxCacheSize: CONFIG.WFS.MAX.CACHE_SIZE,//6000
    keyField: 'id',
    labeling: {
      dataSourcePrefix: 'labels_',
      text: {
        // eslint-disable-next-line no-template-curly-in-string
        pattern: '${imagingTimeEndUTC}\n v${productVersion} (${resolutionDegree})',
        fields: [
          {
            name: 'imagingTimeEndUTC',
            type: 'date',
            format: 'dd/MM/yyyy',
          },
          {
            name: 'productVersion',
            type: 'string',
          },
          {
            name: 'resolutionDegree',
            type: 'number',
            predicate: (value: number) => {
              const res = Object.values(ZOOM_LEVELS_TABLE).indexOf(value);
              return res !== -1 ? res : 'N/A'; 
            },
          },
        ] as ICesiumWFSLayerLabelTextField[],
      },
      fontName: 'sans-serif',
      fontSize: 14,
      padding: 4,
      fillStyle: 'white',
      strokeStyle: 'black',
      lineWidth: 3,
    },
  };

  const handleVisualizationPolygonParts = (
    mapViewer: CesiumViewer,
    dataSource: CesiumGeoJsonDataSource,
    processEntityIds: string[],
    extent?: BBox
  ): void => {
    const is2D = mapViewer.scene.mode === CesiumSceneMode.SCENE2D;
  
    const getGeoJsonFromEntity = (entity: CesiumCesiumEntity): Polygon | undefined => {
      if (entity.polygon) {
        // Polygon
        const polygonData = entity.polygon.hierarchy?.getValue(CesiumJulianDate.now()) as CesiumPolygonHierarchy;
        const positions = polygonData.positions.map((position) => {
          const worlPosCartographic = CesiumCartographic.fromCartesian(position);
          const correctedCarto = new CesiumCartographic(
            CesiumMath.toDegrees(worlPosCartographic.longitude),
            CesiumMath.toDegrees(worlPosCartographic.latitude),
            is2D ? 500 : undefined
          );
          return [correctedCarto.longitude, correctedCarto.latitude, correctedCarto.height];
        });
  
        return {
          type: 'Polygon',
          coordinates: [positions],
        };
      }
    };
  
    const pixelSizeInMeters = (
      scene: CesiumScene,
      position: CesiumCartesian3,
      pixelWidth: number,
      pixelHeight: number
    ): { widthMeters: number; heightMeters: number } | null => {
      const screenPosition = CesiumSceneTransforms.wgs84ToWindowCoordinates(scene, position);
  
      if (!screenPosition) return null;
  
      const xRight = screenPosition.x + pixelWidth;
      const yBottom = screenPosition.y + pixelHeight;
  
      const screenRight = new CesiumCartesian2(xRight, screenPosition.y);
      const screenBottom = new CesiumCartesian2(screenPosition.x, yBottom);
  
      const worldRight = scene.camera.pickEllipsoid(screenRight, scene.globe.ellipsoid);
      const worldBottom = scene.camera.pickEllipsoid(screenBottom, scene.globe.ellipsoid);
  
      if (!worldRight || !worldBottom) return null;
  
      const widthMeters = CesiumCartesian3.distance(position, worldRight);
      const heightMeters = CesiumCartesian3.distance(position, worldBottom);
  
      return { widthMeters, heightMeters };
    };
  
    const createRectangleAround = (centerCartographic: { longitude: number; latitude: number }, widthMeters: number, heightMeters: number): Polygon => {
      const ellipsoid = CesiumEllipsoid.WGS84;
      const lat = centerCartographic.latitude;
      const lon = centerCartographic.longitude;
  
      const metersPerDegreeLat = (Math.PI / 180) * ellipsoid.maximumRadius;
      const metersPerDegreeLon = (Math.PI / 180) * ellipsoid.maximumRadius;
  
      const dLat = heightMeters / 2 / metersPerDegreeLat;
      const dLon = widthMeters / 2 / metersPerDegreeLon;
  
      const north = lat + dLat;
      const south = lat - dLat;
      const east = lon + dLon;
      const west = lon - dLon;
  
      return {
        type: 'Polygon',
        coordinates: [
          [
            [west, north],
            [east, north],
            [east, south],
            [west, south],
            [west, north], // close the ring
          ],
        ],
      };
    };
  
    const calcIntersectionRation = (polygon1: Geometry, polygon2: Geometry) => {
      return area(polygon1) / area(polygon2);
    };
  
    const getCategorizedColor = (res: number): string => {
      const catColor = categoriesColorPalete.find((item) => {
        return res >= item.minRes && res <= item.maxRes;
      });
      return catColor ? catColor.color : BRIGHT_GREEN;
    };
  
    const categoriesColorPalete = [
      {
        minRes: ZOOM_LEVELS_TABLE[22],//1.67638063430786e-7, // 22
        maxRes: ZOOM_LEVELS_TABLE[18],//0.00000268220901489258, // 18
        color: CONFIG.POLYGON_PARTS.STYLE.highResolutionColor, //'#01FF1F', // BRIGHT_GREEN
      },
      {
        minRes: ZOOM_LEVELS_TABLE[17],//0.00000536441802978516, // 17
        maxRes: ZOOM_LEVELS_TABLE[16],//0.0000107288360595703, // 16
        color: CONFIG.POLYGON_PARTS.STYLE.mediumResolutionColor,//'#fbff01', // BRIGHT_YELLOW
      },
      {
        minRes: ZOOM_LEVELS_TABLE[15],//0.0000214576721191406, // 15
        maxRes: ZOOM_LEVELS_TABLE[0],//0.703125, // 0
        color: CONFIG.POLYGON_PARTS.STYLE.lowResolutionColor,//'#ff3401', // BRIGHT_RED
      },
    ];
  
    const labelPos = [] as Feature<Point>[];
  
    dataSource?.entities.values.forEach((entity: CesiumCesiumEntity) => {
      if (extent && is2D) {
        try {
          const extentPolygon = bboxPolygon(extent);
          const featureClippedPolygon = intersect(getGeoJsonFromEntity(entity) as Polygon, extentPolygon) as Feature<Polygon, Properties>;
          if (featureClippedPolygon) {
            const labelValue = entity.properties?.label.getValue(CesiumJulianDate.now());
            const featureClippedPolygonCenter = centroid(featureClippedPolygon as unknown as Polygon, {
              properties: {
                label: labelValue,
              },
            });
  
            const labelPixelSize = { width: labelValue.width, height: labelValue.height };
            const [longitude, latitude, height = 0] = featureClippedPolygonCenter.geometry.coordinates;
            const cartesian = CesiumCartesian3.fromDegrees(longitude, latitude, height);
            const sizeMeters = pixelSizeInMeters(mapViewer.scene, cartesian, labelPixelSize.width, labelPixelSize.height);
  
            if (sizeMeters) {
              const labelRect = createRectangleAround({ longitude, latitude }, sizeMeters.widthMeters, sizeMeters.heightMeters);
  
              const labelIntersection = intersect(featureClippedPolygon, {
                type: 'Feature',
                properties: {},
                geometry: labelRect,
              });
              const intersectionRatio = calcIntersectionRation(labelIntersection?.geometry as Geometry, labelRect);
              if (intersectionRatio > LABEL_INTERSECTION_RATIO) {
                labelPos.push(featureClippedPolygonCenter);
              }
            }
          }
        } catch (e) {
          console.log('*** Label placement failed: turf.intersect() failed ***', 'entity -->', entity, 'extent -->', extent);
        }
      }
      if (processEntityIds.length > 0 && !processEntityIds.some((validId) => entity.id.startsWith(validId))) {
        return;
      }
      if (entity.polygon) {
        const partResolution = entity.properties?.resolutionDegree.getValue(CesiumJulianDate.now());
        const partColor = getCategorizedColor(partResolution);
        entity.polygon = new CesiumCesiumPolygonGraphics({
          hierarchy: entity.polygon.hierarchy,
          material: is2D ? CesiumColor.fromCssColorString(partColor).withAlpha(0.2) : CesiumColor.fromCssColorString(partColor).withAlpha(0.5),
          outline: true,
          outlineColor: CesiumColor.fromCssColorString(partColor),
          outlineWidth: 3,
          height: is2D ? 10000 : undefined, // Mount Everest peak reaches an elevation of approximately 8848.86 meters above sea level
          perPositionHeight: false,
        });
      }
      if (entity.polyline) {
        entity.polyline = new CesiumCesiumPolylineGraphics({
          positions: entity.polyline.positions,
          material: CesiumColor.fromCssColorString(BRIGHT_GREEN).withAlpha(0.5),
          clampToGround: true,
          width: 4,
        });
      }
      if (entity.billboard) {
        const worldPos = entity.position?.getValue(CesiumJulianDate.now()) as CesiumCartesian3;
        const worlPosCartographic = CesiumCartographic.fromCartesian(worldPos);
        const correctedCarto = new CesiumCartographic(
          worlPosCartographic.longitude,
          worlPosCartographic.latitude,
          is2D ? 500 : mapViewer.scene.sampleHeight(CesiumCartographic.fromCartesian(worldPos))
        );
  
        // Convert back to Cartesian3
        const correctedCartesian = CesiumCartesian3.fromRadians(correctedCarto.longitude, correctedCarto.latitude, correctedCarto.height);
  
        entity.position = correctedCartesian as unknown as CesiumPositionProperty;
  
        entity.billboard = new CesiumCesiumBillboardGraphics({
          image:
            'data:image/svg+xml;base64,' +
            btoa(`
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16">
              <circle cx="8" cy="8" r="6" fill="${BRIGHT_GREEN}33" stroke="${POINT_STROKE}80" stroke-width="2"/>
            </svg>
          `), //${BRIGHT_GREEN}33 - with opacity 0.2 ; #FFFF0080 - with opacity 0.5
          verticalOrigin: CesiumVerticalOrigin.BOTTOM,
          heightReference: CesiumHeightReference.NONE, // Ensures it's not clamped and floats above
          scale: 1.0,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
        });
      }
    });
  
    const labelsCollectionName = `labels_${dataSource.name}`;
    const deselectLabelEntities = (entity: CesiumCesiumEntity) => {
      // @ts-ignore
      if (!isEmpty(entity?.entityCollection) && entity.entityCollection.owner.name === labelsCollectionName) {
        mapViewer.selectedEntity = undefined;
      }
    };
  
    mapViewer.dataSources.remove(mapViewer.dataSources.getByName(labelsCollectionName)[0]);
    mapViewer.selectedEntityChanged.removeEventListener(deselectLabelEntities);
    if (is2D) {
      const labelsGeoJsonDataSource = new CesiumGeoJsonDataSource(labelsCollectionName);
      mapViewer.dataSources.add(labelsGeoJsonDataSource);
  
      // Disable click on labels
      mapViewer.selectedEntityChanged.addEventListener(deselectLabelEntities);
  
      labelsGeoJsonDataSource
        .load({
          type: 'FeatureCollection',
          features: labelPos,
        })
        .then((dataSource) => {
          dataSource?.entities.values.forEach((entity: CesiumCesiumEntity) => {
            const worldPos = entity.position?.getValue(CesiumJulianDate.now()) as CesiumCartesian3;
            const worlPosCartographic = CesiumCartographic.fromCartesian(worldPos);
            const correctedCarto = new CesiumCartographic(
              worlPosCartographic.longitude,
              worlPosCartographic.latitude,
              is2D ? 500 : mapViewer.scene.sampleHeight(CesiumCartographic.fromCartesian(worldPos))
            );
  
            const correctedCartesian = CesiumCartesian3.fromRadians(correctedCarto.longitude, correctedCarto.latitude, correctedCarto.height);
  
            entity.position = correctedCartesian as unknown as CesiumPositionProperty;
  
            entity.billboard = new CesiumCesiumBillboardGraphics({
              image: entity.properties?.label.getValue(CesiumJulianDate.now()).dataURL,
              heightReference: CesiumHeightReference.NONE, // Ensures it's not clamped and floats above
              scale: 1.0,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
            });
          });
        });
    }
  };
  return (
    <>
      {
        activeLayer && (
          showFootprint ? <CesiumWFSLayer
              key={metaPolygonParts.id}
              options={optionsPolygonParts}
              meta={metaPolygonParts}
              visualizationHandler={handleVisualizationPolygonParts}
            /> : 
            <CesiumGeojsonLayer
              clampToGround={true}
              data={{
                type: 'FeatureCollection',
                features: [
                  {
                    type: 'Feature',
                    properties: {},
                    geometry: {
                      ...activeLayer?.footprint,
                    },
                  }
                ]
              }}
              onLoad={(geoJsonDataSouce): void => {
                geoJsonDataSouce.entities.values.forEach(item => {
                  if (item.polygon) {
                    item.polygon = new CesiumCesiumPolygonGraphics({
                      hierarchy: item.polygon.hierarchy,
                      material: CesiumColor.fromCssColorString(CONFIG.CONTEXT_MENUS.MAP.POLYGON_PARTS_FEATURE_CONFIG.color),
                      outline: true,
                      outlineColor: CesiumColor.fromCssColorString(CONFIG.CONTEXT_MENUS.MAP.POLYGON_PARTS_FEATURE_CONFIG.outlineColor),
                      outlineWidth: CONFIG.CONTEXT_MENUS.MAP.POLYGON_PARTS_FEATURE_CONFIG.outlineWidth,
                      height: 10000,
                      perPositionHeight: false,
                    });
                  }
                })
              }}
            />
        )
      }
    </>
  );
});